// `plib 6.0.1`
#ifndef PLIB_6
#define PLIB_6

#include <stdint.h>
#include <inttypes.h>
#include <sys/types.h>
#include <stdbool.h>

#define PL_MAX_ARG_V 64


struct plib_Argument {
	char *flag;
	char *shrt;
	char *desc;
	
	uint8_t opt; 
	int idx;
	int  vals[PL_MAX_ARG_V];
};


struct plib_Return {
	int index;
	int code;
};


static int PL_ARG_IDX = 0;
static struct plib_Argument *plib_Arg;
static struct plib_Argument plib_Create_Arg;
static struct plib_Return PL_RETURN;


enum {
	PL_SUCCESS, PL_RETURN_TYPE_END, PL_ARG_NONE,
	PL_ARG_NOT_FOUND, PL_ARG_VALUE, PL_ARG_NO_VALUE,
	PL_TO_MANY_VALUES
};


#define plib_SetRequired(a)            a->opt = a->opt ^ (1u << 3);
#define plib_SetEnabled(a)             a->opt = a->opt ^ (1u << 2);
#define plib_SetTakesMultipleValues(a) a->opt = a->opt ^ (1u << 1);
#define plib_SetTakesValue(a)          a->opt = a->opt ^ (1u << 0);

#define plib_ArgValueCount(a) a->idx
#define plib_GetArgValue(a, n, arv) (n <= a.idx) ? arv[a.vals[n]] : NULL


#define plib_ForEach(n1, n2, ar) \
	plib_Arg = &(ar[n1]);       \
	for(int i = n1; i < n2;i++,    \
			plib_Arg = &(ar[i]))


#define plib_CreateArgCount(ar,c) \
	PL_ARG_IDX += c;               \
	plib_ForEach(0, c, ar){         \
		plib_Arg->opt = (1u << 2);   \
		plib_Arg->idx = 0;            \
	}

#define plib_ForAll(ar) \
	plib_ForEach(0, PL_ARG_IDX, ar)


#define plib_CreateArgForAll(ar)                      \
	plib_CreateArgCount(ar, sizeof(ar) / sizeof(struct plib_Argument)) \
	plib_ForAll(ar) 


#define plib_WasRun(a) \
	(a.idx > 0)


static int
comp(char *s1, char *s2)
{
    while (*s1 && !(*s1 - *s2)) {
        s1++;
        s2++;
    }
    return *s1 - *s2;
}

#include <stdio.h>

// Parse an array for arguments
static struct plib_Return
plib_Parse(int c, char *v[], struct plib_Argument *ar)
{
	struct plib_Return *out = &PL_RETURN;
	
	// No arguments where provided
	if(c <= 1){
		out->index = 0;
		out->code = PL_ARG_NONE;
		return PL_RETURN;
	}
	
	// Loop through arguments 
	for(out->index = 1; out->index < c; ++out->index)
	{
		// Part one: Get the values of an argument.
		// ----------------------------------------
		char *key = v[out->index];
		int arg_s = 0;
		int has_split = 0;

		// `strstr` without the `strstr` 
		while(key[arg_s++]){
			if(key[arg_s] == '=')
				has_split = arg_s;
		}

		char val[arg_s];

		// Get argument value 
		for(int i = 0; i < arg_s; i++){
			if(i > has_split){
				val[i-has_split] = key[i];
				if((i+1) == arg_s) 
					val[i] = '\0';
			}
		}

		// Separate key from value
		for(int i = has_split; i < arg_s; i++)
			key[i-has_split] = key[i+1];



		
		// Part two: search for argument. 
		// ------------------------------
		struct plib_Argument *loc;	
		bool argument_found = false;


		// Search for argument in argument list
		for(int i = 0; i < PL_ARG_IDX; i++)
			if(comp(ar[i].flag, key) == 0){
				loc = &ar[i];
				argument_found = true;
			}

		// Argument was not found
		if(!argument_found){
			out->code = PL_ARG_NOT_FOUND;
			return PL_RETURN;
		}


		// Skip if argument is not enabled
		if(!(loc->opt & (1u << 2))){
			continue;
		}


		// Part three: Handle conditionals.
		// --------------------------------
		if (loc->opt & 1u){
			if(val[0] == '\0'){
				// Argument takes a value but none was provided
				out->code = PL_ARG_NO_VALUE;
				return PL_RETURN;
			}
		} else if (val[0] != '\0'){
			// Argument does not take a value but one was provided.
			out->code = PL_ARG_VALUE;
			return PL_RETURN;
		}

		// Part four: assignment.
		
		if((loc->idx == 1 && (loc->opt & (1u << 1))) || loc->idx == PL_MAX_ARG_V){
			out->code = PL_TO_MANY_VALUES;
			return PL_RETURN;
		}

		loc->vals[loc->idx++] = out->index;
	}

	out->code = PL_SUCCESS;
	return PL_RETURN;
}
#endif
