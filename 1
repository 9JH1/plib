// `plib 6.0.1`
#ifndef PLIB_6
#define PLIB_6

#include <stdint.h>
#include <inttypes.h>
#include <sys/types.h>
#include <stdbool.h>

#define PL_MAX_ARG_V 64


struct plib_Argument {
	char *flag;
	char *shrt;
	char *desc;
	
	uint8_t opt; 
	int idx;
	int  vals[PL_MAX_ARG_V];
};



struct plib_Return {
	int index;
	int code;
};



static int PL_ARG_IDX = 0;
static struct plib_Argument *plib_Arg;
static struct plib_Argument plib_Create_Arg;
static struct plib_Return PL_RETURN;



enum {
	PL_SUCCESS, PL_RETURN_TYPE_END, PL_ARG_NONE,
	PL_ARG_NOT_FOUND, PL_ARG_VALUE, PL_ARG_NO_VALUE,
	PL_TO_MANY_VALUES
};



#define plib_SetRequired(a)            a->opt = a->opt ^ (1u << 3);
#define plib_SetEnabled(a)             a->opt = a->opt ^ (1u << 2);
#define plib_SetTakesMultipleValues(a) a->opt = a->opt ^ (1u << 1);
#define plib_SetTakesValue(a)          a->opt = a->opt ^ (1u << 0);


#define plib_ForEach(n1, n2, ar) \
	plib_Arg = &(ar[n1]);       \
	for(int i = n1; i < n2;i++,    \
			plib_Arg = &(ar[i]))


#define plib_CreateArgCount(ar,c) \
	PL_ARG_IDX += c;               \
	plib_ForEach(0, c, ar){         \
		plib_Arg->opt = 1u << 2;     \
		plib_Arg->idx = 0;            \
	}

#define plib_ForAll(ar) \
	plib_ForEach(0, PL_ARG_IDX, ar)


#define plib_ArrayLength(ar) \
	sizeof(ar) / sizeof(struct plib_Argument)


#define plib_CreateArgForAll(ar)                      \
	plib_CreateArgCount(ar, (int)plib_ArrayLength(ar)) \
	plib_ForAll(ar) 


#define plib_WasRun(a) \
	(a.idx > 0)


#define plib_CreateArg(ar, c) \
	plib_Create_Arg = (ar[c]);     \
	while(0)


#define plib_Create_Name(name) \
	snprintf(plib_Create_Arg.flag, PL_FLAG_MAX, "%s", name;


#define plib_ArgValueCount(a) a->idx

static int
comp(char *s1, char *s2)
{
    while (*s1 && !(*s1 - *s2)) {
        s1++;
        s2++;
    }
    return *s1 - *s2;
}

static int pl_uint8_t_read(uint8_t *word, uint8_t n){return (*word & (1u << n));}

// Parse an array for arguments
static struct plib_Return
plib_Parse(int c, char *v[], struct plib_Argument *ar)
{
	struct plib_Return *out = &PL_RETURN;
	
	// No arguments where provided
	if(c <= 1){
		out->index = 0;
		out->code = PL_ARG_NONE;
		return PL_LAST_RETURN;
	}
	
	// Loop through arguments 
	for(out->index = 1; out->index < c; ++out->index)
	{
		// Part one: Get the values of an argument.
		// ----------------------------------------
		char *arg = v[out->index];
		int arg_s = 0;
		int has_split = 0;

		// `strstr` without the `strstr` 
		while(arg[arg_s++]){
			if(arg[arg_s] == '=')
				has_split = 1;
		}

		char key[arg_s];
		char val[arg_s];
		int key_idx = 0;
		int val_idx = 0;

		bool toggle = false;

		// `strtok` without the `strtok`
		// Loop through letters of argument
		for(int i = 0; i < arg_s; i++){
			if(has_split && arg[i] == '='){
				toggle = true;
				continue;
			}

			// Separate values for the key and value.
			if(toggle) val[val_idx++] = arg[i];
			else       key[key_idx++] = arg[i];
			
			// Null-terminate strings
			if((i+1) == arg_s) 
				key[key_idx] = val[val_idx] = '\0';
		}
		
		// Part two: search for argument. 
		// ------------------------------
		struct plib_Argument *loc;	
		bool argument_found = false;


		// Search for argument in argument list
		for(int i = 0; i < PL_ARG_IDX; i++)
			if(comp(ar[i].flag, key) == 0){
				loc = &ar[i];
				argument_found = true;
			}
		
		// Argument was not found
		if(!argument_found){
			out->code = PL_ARG_NOT_FOUND;
			return PL_LAST_RETURN;
		}


		// Part three: Handle conditionals.
		// --------------------------------
		if (pl_uint8_t_read(&loc->opt, 0)){
			if(val[0] == '\0'){
				// Argument takes a value but none was provided
				out->code = PL_ARG_NO_VALUE;
				return PL_LAST_RETURN;
			}
		} else if (val[0] != '\0'){
			// Argument does not take a value but one was provided.
			out->code = PL_ARG_VALUE;
			return PL_LAST_RETURN;
		}

		// Part four: assignment.
		
		if((loc->idx == 1 && pl_uint8_t_read(&loc->opt, 1)) || loc->idx == PL_MAX_ARG_V){
			out->code = PL_TO_MANY_VALUES;
			return PL_LAST_RETURN;
		}

		loc->vals[loc->idx++] = out->index;
	}

	out->code = PL_SUCCESS;
	return PL_LAST_RETURN;
}
#endif
